. 匹配除换行符意外所有的字符

\w 匹配字母或数字或下划线或汉字

\s匹配任意的 空白符

\d 数字

^开始

$结尾

\b匹配单词的开始或结束



   *重复零次或更多次
   +重复一次或更多次

   ？重复零次或一次

​	{n}  重复n次

​    {n,} 重复n次或更多次

​	{n,m} 重复n到m次



1\d{10}



转义  \

条件或  |

区间 []    

1限定0-9  [0--9]

2.限定A-Z  



### 正则进阶

1.**零宽断言**

①.正向先行断言（正前瞻）

- 语法：（?=pattern）

- 作用：匹配pattern表达式的前面内容，不返回本身。

   例如：(?=</span>) 

  ```java
  String reg=".+(?=</span>)";
   2
   3   String test = "<span class=\"read-count\">阅读数：641</span>";
   4   Pattern pattern = Pattern.compile(reg);
   5   Matcher mc= pattern.matcher(test);
   6   while(mc.find()){
   7    System.out.println("匹配结果：")
   8    System.out.println(mc.group());
   9   }
  10
  11   //匹配结果：
  12   //<span class="read-count">阅读数：641
  ```

  可是老哥我们要的只是前面的数字呀，那也简单咯，匹配数字 \d,那可以改成：

  ```java
  1   String reg="\\d+(?=</span>)";
  2   String test = "<span class=\"read-count\">阅读数：641</span>";
  3   Pattern pattern = Pattern.compile(reg);
  4   Matcher mc=    pattern.matcher(test);
  5   while(mc.find()){
  6     System.out.println(mc.group());
  7   }
  8   //匹配结果：
  9   //641
  ```

2.正向后行断言（正后顾）

- 语法：(?<=parrern)
- 作用：匹配pattern表达式的后面的内容，不返回本身

有先行就有后行，先行是匹配前面的内容，那后行就是匹配后面的内容啦。

上面的栗子，我们也可以用后行断言来处理.

```java
 1   //(?<=<span class="read-count">阅读数：)\d+
 2   String reg="(?<=<span class=\"read-count\">阅读数：)\\d+";
 3
 4   String test = "<span class=\"read-count\">阅读数：641</span>";
 5   Pattern pattern = Pattern.compile(reg);
 6   Matcher mc=    pattern.matcher(test);
 7        while(mc.find()){
 8          System.out.println(mc.group());
 9        }
10   //匹配结果：
11   //641
```



3. 负向先行断言（负前瞻）

- 语法：(?!pattern)
- 作用：匹配非pattern表达式的前面内容，不返回本身。

有正向也有负向，负向在这里其实就是非的意思。
举个栗子：比如有一句 “我爱祖国，我是祖国的花朵”
现在要找到不是'的花朵'前面的祖国
用正则就可以这样写：

```java
1   祖国(?!的花朵)
```

4. 负向后行断言（负后顾）

- 语法：(?<!pattern)
- 作用：匹配非pattern表达式的后面内容，不返回本身。

### **2. 捕获和非捕获**

单纯说到捕获，他的意思是匹配表达式，但捕获通常和分组联系在一起，也就是“捕获组”

> 捕获组：匹配子表达式的内容，把匹配结果保存到内存中中数字编号或显示命名的组里，以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。

而根据命名方式的不同，又可以分为两种组：

1. 数字编号捕获组：
   语法：(exp)
   解释：从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，在分组中，第0组为整个表达式，第一组开始为分组。

比如固定电话的：020-85653333
他的正则表达式为：(0\d{2})-(\d{8})

2. 命名编号捕获组：
   语法：(?<name>exp)
   解释：分组的命名由表达式中的name指定
   比如区号也可以这样写:(?<quhao>\0\d{2})-(?<haoma>\d{8})



3. 非捕获组：
   语法：(?:exp)
   解释：和捕获组刚好相反，它用来标识那些不需要捕获的分组，说的通俗一点，就是你可以根据需要去保存你的分组。

比如上面的正则表达式，程序不需要用到第一个分组，那就可以这样写：

```java
1   (?:\0\d{2})-(\d{8})
```

 

### **3. 反向引用**

上面讲到捕获，我们知道：**捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用**。

根据捕获组的命名规则，反向引用可分为：

1. 数字编号组反向引用：\k
   或\number
2. 命名编号组反向引用：\k
   或者\'name'



比如要查找一串字母"aabbbbgbddesddfiid"里成对的字母
如果按照我们之前学到的正则，什么区间啊限定啊断言啊可能是办不到的，
现在我们先用程序思维理一下思路：

- 1）匹配到一个字母
- 2）匹配第下一个字母，检查是否和上一个字母是否一样
- 3）如果一样，则匹配成功，否则失败

这里的思路2中匹配下一个字母时，需要用到上一个字母，那怎么记住上一个字母呢？？？
这下子捕获就有用处啦，我们可以利用捕获把上一个匹配成功的内容用来作为本次匹配的条件
好了，有思路就要实践
首先匹配一个字母：\w
我们需要做成分组才能捕获，因此写成这样：(\w)

那这个表达式就有一个捕获组：（\w）
然后我们要用这个捕获组作为条件，那就可以：(\w)\1
这样就大功告成了
可能有人不明白了，\1是什么意思呢？
还记得捕获组有两种命名方式吗，**一种是是根据捕获分组顺序命名，一种是自定义命名来作为捕获组的命名**
***在默认情况下都是以数字来命名，而且数字命名的顺序是从1开始的***
因此要引用第一个捕获组，根据反向引用的数字命名规则 就需要 \k<1>或者\1
当然，通常都是是后者。
我们来测试一下：

```java
1   String test = "aabbbbgbddesddfiid";
2        Pattern pattern = Pattern.compile("(\\w)\\1");
3        Matcher mc= pattern.matcher(test);
4        while(mc.find()){
5            System.out.println(mc.group());
6
7        }
```

输出结果：

```java
1   aa
2   bb
3   bb
4   dd
5   dd
6   ii
```

嗯，这就是我们想要的了。

在举个替换的例子，假如想要把字符串中abc换成a

```java
1   String test = "abcbbabcbcgbddesddfiid";
2   String reg="(a)(b)c";
3   System.out.println(test.replaceAll(reg, "$1"));;
```

输出结果：

```java
1   abbabcgbddesddfiid
```



### **4. 贪婪和非贪婪**

1.**贪婪**

贪婪匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这匹配方式叫做贪婪匹配。
特性：一次性读入整个字符串进行匹配，每当不匹配就舍弃最右边一个字符，继续匹配，依次匹配和舍弃（这种匹配-舍弃的方式也叫做回溯），直到匹配成功或者把整个字符串舍弃完为止，因此它是一种最大化的数据返回，能多不会少。

**2. 懒惰（非贪婪）**

> 懒惰匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能少的字符，这匹配方式叫做懒惰匹配。
> 特性：从左到右，从字符串的最左边开始匹配，每次试图不读入字符匹配，匹配成功，则完成匹配，否则读入一个字符再匹配，依此循环（读入字符、匹配）直到匹配成功或者把字符串的字符匹配完为止。

懒惰量词是在贪婪量词后面加个“？”

![img](https://pic1.zhimg.com/50/v2-7c7f10a4fdb67136e113611baab550d9_hd.jpg)![img](https://pic1.zhimg.com/80/v2-7c7f10a4fdb67136e113611baab550d9_720w.jpg)



### **5. 反义**

前面说到元字符的都是要匹配什么什么，当然如果你想反着来，不想匹配某些字符，正则也提供了一些常用的反义元字符：

![img](https://pic2.zhimg.com/50/v2-d7dae5a859d6851c8620108c83227390_hd.jpg)![img](https://pic2.zhimg.com/80/v2-d7dae5a859d6851c8620108c83227390_720w.jpg)
